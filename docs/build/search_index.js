var documenterSearchIndex = {"docs":
[{"location":"overview.html#Linear-SDP-problem","page":"Overview","title":"Linear SDP problem","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"beginalign*\nmin c^Tx \ntextst\nquadsum_i=1^n x_i A_i - B succeq 0\nendalign*","category":"page"},{"location":"overview.html","page":"Overview","title":"Overview","text":"where x","category":"page"},{"location":"Loraine_options.html#Options","page":"Loraine Options","title":"Options","text":"","category":"section"},{"location":"Loraine_options.html","page":"Loraine Options","title":"Loraine Options","text":"The list of Loraine options (default values are in the [bracket]):","category":"page"},{"location":"Loraine_options.html","page":"Loraine Options","title":"Loraine Options","text":"kit             # kit = 0 for direct solver; kit = 1 for CG [0]\ntol_cg          # initial tolerance for CG solver [1.0e-2]\ntol_cg_up       # tolerance update [0.5]\ntol_cg_min      # minimal tolerance for CG solver [1.0e-6]\neDIMACS         # epsilon for DIMACS error stopping criterion [1.0e-5]\npreconditioner  # 0...no; 1...H_alpha; 2...H_beta; 4...hybrid [1]\nerank           # estimated rank [1]\naamat           # 0..A^TA; 1..diag(A^TA); 2..identity [2]\nverb            # 2..full output; 1..short output; 0..no output [1]\ndatarank        # 0..full rank matrices expected [0]\n                # -1..rank-1 matrices expected, converted to vectors, if possible\n                # (TBD) 1..vectors expected for low-rank data matrices\ninitpoint       # 0..Loraine heuristics, 1..SDPT3-like heuristics [0]\ntiming          # 1..yes, 0..no\nmaxit           # maximal number of global iterations [200]","category":"page"},{"location":"Loraine_options.html#Comments","page":"Loraine Options","title":"Comments","text":"","category":"section"},{"location":"Loraine_options.html","page":"Loraine Options","title":"Loraine Options","text":"eDIMACS is checked against the maximum of DIMACS errors, measuring (weighted) primal and dual infeasibility, complementary slackness and duality gap.  \nfor the direct solver (kit = 0), value about 1e-7 should give a similar precision as default MOSEK\nfor the iterative solver (kit = 1), eDIMACS may need to be increased to 1e-6 or even 1e-5 to guarantee convergence of Loraine.\nfor the iterative solver (kit = 1), tol_cg_min should always be smaller than or equal to eDIMACS\npreconditioner\nper CG iteration, 0 is faster (lower complexity) than 2 which is faster than 1\nas a preconditioner, 1 is better than 2 is better than 0, in the sence of CG iterations needed to solve the linear system\nsome  SDP problems are \"easy\", meaning that CG always converges without preconditioner (i.e., `preconditioner = 0'), so it's always worth trying this option\nhybrid (preconditioner = 4) starts with (cheaper) H_beta and once it gets into difficulties, switches to H_alpha\nerank (only used when kit = 1 and preconditioner > 0)\nif you are not sure what the actual rank of the solution is, always choose erank = 1; with inreasing value of erank, the complexity of the preconditioner grows and the whole code could be slower, despite neding fewer CG iterations\nonly if you are sure about the rank of the solution, set erank to this value (but you should always compare it to erank = 1)\ndatarank (only used with the direct solver kit = 0)\nchoose datarank = -1 if you know (or suspect) that all the data matrices A_i have rank one; in this case, the matrices will be factorized as A_i = b_i b_i^T and vectors b_i will be used when constructing the Schur complement matrix\nif you are not sure about the rank of the data matrices, you can always try to set datarank = -1; if the factorization of any matrix fails, Lorain will switch to the default option datarank = 0\nfor rank-one data matrices, option datarank = -1 will result in a much faster code than the default datarank = 0\ntiming is not used when Loraine is called from JuMP\ntol_cg, tol_cg_up, aamat: it is not recommended to change values of these options, unless you really want to","category":"page"},{"location":"index.html#Loraine.jl","page":"Index","title":"Loraine.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Loraine.jl is a Julia implementation of an interior point method algorithm for linear semidefinite optimization problems. ","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The special feature of Loraine is the iterative solver for linear systems. This is to be used for problems with (very) low rank solution matrix.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"Standard (non-low-rank) problems and linear programs can be solved using the direct solver; then the user gets a standard IP method akin SDPT3.","category":"page"},{"location":"index.html#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Install Loraine using Pkg.add:","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"import Pkg\nPkg.add(\"Loraine\")","category":"page"},{"location":"index.html#License-and-Original-Contributors","page":"Index","title":"License and Original Contributors","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Loraine is licensed under the MIT License.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"Loraine was developed by Soodeh Habibi and Michal Kočvara, University of Birmingham, and Michael Stingl, University of Erlangen, for H2020 ITN POEMA. ","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The JuMP interface was provided by Benoît Legat. His help is greatly acknowledged.","category":"page"},{"location":"index.html#Citing","page":"Index","title":"Citing","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"If you find Loraine useful, please cite the following paper:","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"@article{loraine2023,\n  title={Loraine-An interior-point solver for low-rank semidefinite programming},\n  author={Habibi, Soodeh and Ko{\\v{c}}vara, Michal and Stingl, Michael},\n  www={https://hal.science/hal-04076509/}\n  note={Preprint hal-04076509}\n  year={2023}\n}","category":"page"}]
}
